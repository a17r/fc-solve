<?xml version='1.0' ?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" 
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"[

<!ENTITY fcs "Freecell Solver">
]>

<book id="index">
    <bookinfo>
        <title>&fcs; - Architecture Document</title>

        <authorgroup>
            <author>
                <firstname>Shlomi</firstname>
                <surname>Fish</surname>
                <affiliation>
                    <address>
                        <email>shlomif@iglu.org.il</email>
                    </address>
                </affiliation>
            </author>
        </authorgroup>
        <releaseinfo>This is version 0.2.0</releaseinfo>

        <copyright>
            <year>2002</year>
            <holder>Shlomi Fish</holder>
        </copyright>

        <legalnotice>
            <!-- Ci vis pacem -->
            <para>              
                <!-- belum. ;-) -->
                This work is licensed under the 
                <ulink url="http://creativecommons.org/licenses/by/3.0/">Creative 
                    Commons Attribution 3.0 Unported License</ulink> (or at 
                your option a greater version of it).
            </para>
            <para>
                It was written by
                <ulink url="http://www.shlomifish.org/">Shlomi Fish</ulink>, 
                and one should attribute a derived work to him, while linking
                to his homepage.
            </para>
        </legalnotice>
        <revhistory>
            <revision>
                <revnumber>1.6</revnumber>
                <date>2 December 2002</date>
                <authorinitials>shlomif</authorinitials>
                <revremark>
                    First "stable" version covering the &fcs; 2.8.x 
                    architecture. Spell checked and revised during its
                    CVS history.
                </revremark>
            </revision>
            <revision>
                <revnumber>835</revnumber>
                <date>11 July 2008</date>
                <authorinitials>shlomif</authorinitials>
                <revremark>
                    Combined everything into one big .xml file instead of
                    the "SYSTEM" entities. Removed the places where
                    vipe.technion.ac.il was mentioned.
                </revremark>
            </revision>
        </revhistory>
    </bookinfo>

    <chapter id="introduction">
        <title>Introduction</title>
        <para>
            This is the architecture document of &fcs;. Its purpose is to
            serve as an introduction to the code, so future hackers can 
            understand it and work on it.
        </para>
        <para>
            This document does not aim to cover every detail of the 
            application. Such details are supposed to be documented within
            the comments of the code. (let me know if there is something 
            there you don't understand, and I'll add a comment) Instead,
            it should provide an overview of the code and cover the main
            caveats one would encounter when trying to understand it.
        </para>
        <para>
            This document covers the &fcs; 2.8.x architecture, and will
            be updated to future versions.
        </para>
    </chapter>
    <chapter id="coding_conventions">
        <title>Coding Conventions</title>
        <section id="bottom_up_design_and_evolution">
            <title>Bottom-Up Design and Evolution</title>
            <para>
                &fcs; was designed bottom-up: first by writing functions to input
                cards and then to handle states and finally the algorithm itself. I
                find that bottom-up design (as evangelized by Paul Graham and 
                others)- start by writing small utility functions and classes 
                and then integrate into a grander scheme, has been a guiding 
                principle when working on &fcs;.
            </para>
            <para>
                &fcs; has many utility classes, and has also been coded 
                incrementally. I also find bottom-up design more natural.
            </para>
        </section>
        <section id="strict_adherence_to_the_ansi_c_lang">
            <title>Strict Adherence to the ANSI C Language</title>
            <para>
                &fcs; is written in pure ANSI C and uses no gcc extensions, no 
                C99 or C++ extensions. I did allow myself to make use of
                <emphasis>inline</emphasis> in some places, but they are isolated
                to be compiled with gcc alone.
            </para>
            <para>
                &fcs; is actively compiled with gcc and with the Visual C++
                ANSI C compiler. I expect that it should be compilable with
                other proprietary compilers on various systems. As this variety
                of compilers only support the bare ANSI C standard, I have 
                to stick to it. This is despite the fact that such extensions may
                have made the code more optimized and my life as a programmer much 
                easier.            
            </para>
        </section>
        <section id="strict_adherence_to_the_ansi_c_standard_lib">
            <title>Strict Adherence to the ANSI C Standard Library</title>
            <para>
                &fcs; is dependant on the ANSI C Standard Library as defined
                by the standard and on that library alone. The core FCS code is
                not dependant on glib, apr or any other abstraction or 
                encapsulation libraries of this kind.
            </para>
            <para>
                &fcs; can optionally be compiled to make use of some binary trees
                and hash implementations found in external libraries. This 
                serves as a drop-in replacement for its internal hash 
                implementation, which was shown to usually give better results.
            </para>
            <para>
                Note that a lot of the logic provided by such libraries is 
                implemented internally in &fcs;.
            </para>
        </section>
        <section id="cc_namespace_purity">
            <title>Namespace Purity</title>
            <para>
                All the global symbols of the &fcs; modules are prefixed with
                <symbol>freecell_solver_</symbol> prefix. Some macros supplied 
                to the user are prefixed with the <symbol>fcs_</symbol> prefix for convenience.
            </para>
            <para>
                As a general rule the naming convention is 
                <symbol>freecell_solver_[class name]_[method name]</symbol>. The identifiers
                also tend to be very verbose.
            </para>
        </section>
        <section id="cc_order_of_tradeoffs">
            <title>Order of Trade-offs in the Design of the Code</title>
            <para>
                &fcs; has the following trade offs in the design of the code:
            </para>
            <para>
                <orderedlist>
                    <listitem>
                        <para>
                            Modularity - the code should be as generic as possible
                            and allow for maximal flexibility. The user should
                            be able to configure the library as he pleases.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Speed - the code should be optimized for speed. Many 
                            times in the code, it was made a bit less 
                            comprehensible to gain speed, and many times extra
                            techniques are implemented to ensure this goal.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Memory Consumption - should be reduced as much as
                            possible. A reduced memory consumption usually leads
                            to better speed, because there are less cache misses
                            this way.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Smart Algorithms - generally, algorithms with a low
                            complexity and such that give advantage to the code
                            are implemented.
                        </para>
                    </listitem>                
                </orderedlist>
            </para>

            <para>
                Note that these trade-offs are subject to the programmer's whims,
                and many times, one was a bit sacrificed to satisfy the other.
            </para>
        </section>
        <section id="cc_no_global_symbols">
            <title>No Global or Static Variables</title>
            <para>
                &fcs; does not use global variables (except for constants) or such 
                that are statically defined within a function. All the non-temporary
                variables are present within structs, so they can easily be
                instantiated.
            </para>
            <para>
                One should note that several distinct instances of the solving 
                algorithm can be instantiated and made to run side by side or 
                alternately.
            </para>
        </section>
        <section id="cc_separation_of_internals_from_user_interface">
            <title>Separation of Internals from User and Application Programmer Interfaces</title>
            <para>
                FCS makes a clear distinction between the internals of the program,
                that are subject to change from version to version, and between the
                interface supplied to the user or the application programmer. All 
                the modules starting from <filename>intrface.c</filename> and below 
                are the internals of the program.
            </para>        
            <para>
                <filename>lib.c</filename> contain the API functions used by the
                programmer. <filename>cmd_line.c</filename> is an API to analyze
                a &fcs; command line. It itself uses only the 
                <filename>lib.c</filename> API. It provides a more flexible
                interface for configuring &fcs;, even to the application 
                programmer.
            </para>
            <para>
                <filename>main.c</filename> and 
                <filename>test_multi_parallel.c</filename> are two command line
                programs that use the command line interface and programmers 
                interface. Others can be written (and have been).
            </para>
        </section>
    </chapter>
    <chapter id="code_overview">
        <title>Overview of the Code</title>
        <section id="overview_of_the_program">
            <title>Overview of the Program</title>

            <para>
                &fcs; solves boards by using Depth-First Search or 
                Best-First-Search scans starting from the initial board. It has 
                a collection of the states, and constructs a tree of the 
                states descending from each state to its "parent". A parent state 
                means the state in which from which it was discovered.
            </para>

            <para>
                &fcs; can run several "tests" on each state. Each test generates
                a list of derived states. Some of the tests are Freecell meta-move 
                ones, some are Freecell atomic move ones, and the others are 
                Simple Simon meta-move ones. The order of the tests can be 
                specified at the command line, and tests can be grouped, and 
                the order of checking of the tests within a group will be 
                determined by a special callback.
            </para>
            <para>
                To perform the scans themselves Freecell Solver distinguishes 
                between soft threads, hard threads and instances. An instance is 
                a collection of states and an initial board to explore. Each 
                instance may have several hard threads and each hard thread may 
                have several soft threads. A hard thread is something
                that would likely be put in a system thread. It contains such 
                resources, that a collision between them among several hard 
                threads running in parallel is undesirable. Nevertheless, 
                every hard thread can access the resources allocated by other 
                hard threads, should he encounter them in his scan.
            </para>
            <para>
                A soft thread is a singular scan. It performs a scan for a 
                certain number of iterations, at which point the hard thread 
                switches to a different soft thread.
            </para>
        </section>
        <section id="overview_of_the_utility_modules">
            <title>Overview of the Utility Modules</title>
            <section id="app_str.c">
                <title>app_str.c</title>
                <para>
                    This file contains a utility class that appends sprintf'ed 
                    output to a dynamically allocated buffer while growing the 
                    buffer if necessary.
                </para>
                <para>
                    It is still possible that the sprintf will generate a long
                    enough string that will cause a buffer overflow. However,
                    since the class is only used to render states into strings,
                    and the margin allowed for the buffer is long enough, this
                    cannot actually happen.
                </para>
            </section>
            <section id="lookup2.c">
                <title>lookup2.c</title>
                <para>
                    This module implements a 
                    <ulink url="http://burtleburtle.net/bob/hash/">hash function</ulink> 
                    that was developed by <ulink url="http://burtleburtle.net/bob/">Bob Jenkins</ulink>. 
                    
                    It is essentially his code, that was just integrated into 
                    &fcs; for convenience (note that it is also Public Domain).
                </para>
            </section>
            <section id="rand.c">
                <title>rand.c and rand.h</title>
                <para>
                    Implements a random number generating class. The algorithm is
                    identical to that of the Microsoft C Run-Time Library (RTL),
                    but the generator can be instantiated.
                </para>
            </section>
            <section id="fcs_hash.c">
                <title>fcs_hash.c</title>
                <para>
                    An optimized hash implementations. This has maps keys alone,
                    not key-value pairs. It stores the hash values next to the 
                    keys, so two keys can be first compared with their hash values,
                    before the costly full comparison is done. It also uses
                    a secondary hash to speed up the detection of two keys with
                    identical primary hash values.
                </para>
                <para>
                    Not all the functions of the hash Abstract Data Type are
                    implemented here. Only these that need to be used by 
                    Freecell Solver.
                </para>
            </section>
            
            <section id="fcs_dm.c">
                <title>fas_dm.c</title>
                <para>
                    This module implements two functions - an advanced binary
                    search one and a function to merge a small sorted array into
                    a larger sorted array. It was used until the newer hash or
                    balanced binary tree storage were implemented, and may still
                    be used if <symbol>FCS_STATE_STORAGE_INDIRECT</symbol>
                    or <symbol>FCS_STACK_STORAGE_INDIRECT</symbol> are specified.
                    <footnote id="sorted_array_as_storage">
                        <para>
                            It is no longer recommended to use a sorted array as
                            a state or stack storage, as they are much slower than
                            using a hash or a balanced binary tree, both in 
                            asymptotic complexity (O(n<superscript>2</superscript>))) 
                            and in average performance.
                        </para>
                    </footnote>
                </para>
            </section>

            <section id="fcs_isa.c">
                <title>fcs_isa.c</title>
                <para>
                    This module implements indirect stack allocation to states. 
                    It allocates every states in memory pools (called packs) which 
                    have a fixed location in memory and allocates as many such 
                    pools as it can.
                </para>

                <para>
                    Each pool contains several states that are placed one after 
                    the other, that thus retain their pointer. That way, memory 
                    is conserved as an individually malloced state may have a 
                    lot of overhead. (a malloced block+a fixed amount of data is 
                    rounded to the nearest power of 2)
                </para>
                <para>
                    fcs_isa allows releasing the last allocated state in case it 
                    will not be used.
                </para>
            </section>

            <section id="alloc.c">
                <title>alloc.c</title>
                <para>
                    This module is a more sophisticated version of fcs_isa.c. What 
                    it does is compactly allocate blocks of arbitrary length, 
                    usually used for dynamically allocated Freecell columns.
                </para>
            </section>
            

            <section id="cl_chop.c">
                <title>cl_chop.c</title>
                <para>
                    This module contains a class that implements a chopping of a 
                    string into arguments. This is done using a subset of the 
                    UNIX Bourne shell functionality. Namely:
                </para>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>
                                A backslash (\) makes the next character an 
                                actual such character.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                A newline or a whitespace separates a word.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                A backslash at the end of the line continues the 
                                processing.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Double quotes (") wrap an argument that may contain
                                whitespace.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                A pound sign (#) makes a comment that extends
                                to the end of the line.
                            </para>
                        </listitem>                    
                    </orderedlist>
                </para>
                <para>
                    The code itself is very spaghetti-like but it is working.
                </para>
            </section>
            <section id="pqueue.c">
                <title>pqueue.c</title>
                <para>
                    This module implements a priority queue as a binary heap. It
                    is derived from <ulink url="http://www.geocities.com/SiliconValley/Lakes/4929/">Justin Heyes-Jones</ulink> C++ code which he has kindly 
                    donated to &fcs; (while relicensing it under the public 
                    domain). Since then, the code has been converted to ANSI C
                    , modified and optimized.
                </para>
                <para>
                    This module is used by the Best-First-Search scan.
                </para>
            </section>
        </section>
        <section id="overview_of_the_core_modules">
            <title>Overview of the Core Modules</title>
            <para>
                Bottom-up
            </para>
            <section id="card.c">
                <title>card.c</title>
                <para>
                    Elementary functions to convert cards to and from their 
                    string representations. The <symbol>u</symbol> and
                    <symbol>p</symbol> within the code stand for "user" and
                    "perl" respectively, and mean user representation and 
                    internal C representation.
                </para>
                <para>
                    The first experimental version of &fcs; was written in
                    Perl, and since then the naming convention for this case 
                    persisted.
                </para>
            </section>

            <section id="state.h">
                <title>state.h</title>
                <para>
                    This is a header file, but it can be considered a module
                    due to the large amount of logic that it implements. It defines 
                    fcs_state_t (which represents a complete layout of the 
                    Freecell board) and of fcs_state_with_locations_t. It contains
                    many macros for manipulating states and cards. (all of them 
                    should behave like function calls)
                </para>
                <para>
                    The state_with_locations_t contains the real positions of the
                    stacks and freecells (refer to (SECTION_REF Canonization and
                    Normalization)) and other things that the system uses but 
                    don't uniquely identify the state in the state collection.
                </para>
            </section>

            <section id="state.c">
                <title>state.c</title>
                <para>
                    This file contains various functions for manipulating states.
                    Among the many things implemented in it are state canonization,
                    state duplicating, state comparison and converting to and from
                    string format.
                </para>
            </section>

            <section id="move.c">
                <title>move.c and move.h</title>
                <para>
                    This module contains routines for handling individual moves
                    (freecell &rarr; stack, stack &rarr; freecell, stack &rarr;
                    stack) and various special moves as well as entire move 
                    stacks, which contain a sequence of moves to be played 
                    between two intermediate states.
                </para>
            </section>
            
            <section id="preset.c">
                <title>preset.c</title>
                <para>
                    This file manages the presets: configurations of stacks
                    number, freecells number, decks number, and the other 
                    parameters that define how a game is played. A preset is a 
                    variant of Solitaire such as Freecell, Baker's Game, Simple 
                    Simon, Good Measure, etc. Many of them are categorized in 
                    PySol under different categories than the Freecell category. 
                    Moreover, some "Freecell-like" games such as Penguin are not
                    supported by Freecell Solver yet.
                </para>
                <para>
                    The routines in the file enable applying a preset to an 
                    instance (by its name), applying a preset to an instance
                    by a pointer to it, etc. It is also directly used by lib.c
                    to maintain consistency across a sequence of consecutive 
                    instances.
                </para>
            </section>

            <section id="freecell.c">
                <title>freecell.c</title>
                <para>
                    This module contains "test functions" for Freecell tests. A 
                    test receives an origin state and tries to deduce if moves of 
                    a certain sort are possible. It fills in a derived states list.
                </para>
                <para>
                    This code uses some macros defined in tests.h. It contains
                    both meta-move tests and atomic moves ones.
                </para>
            </section>

            <section id="simpsim.c">
                <title>simpsim.c</title>
                <para>
                    This file is similar in spirit to 
                    <filename>freecell.c</filename> only it contains
                    Simple Simon tests.
                </para>
            </section>

            <section id="caas.c">
                <title>caas.c</title>
                <para>
                    This file contains the <function>check_and_add_state</function> 
                    function - a function that is used to determine if a reached 
                    state is found in the states collection and if so, to insert 
                    it there. (an operation that can be considered atomic). 
                </para>
                <para>
                    It has several macros used to do it for the various types of 
                    states collections supported at compile time. It also has a 
                    function to collect the new stacks that were present in a 
                    similar fashion.
                </para>
                <para>
                    It is being used by the tests functions to put a state in 
                    the state collection.
                </para>
            </section>

            <section id="scans.c">
                <title>scans.c</title>
                <para>
                    This module contains the functions of the various scans and 
                    their auxiliary functions. The scan functions run tests and 
                    traverse the graph according to some inherent logic. Currently 
                    present are random-dfs/soft-dfs (soft-dfs is random-dfs 
                    without randomizing groups), Hard-DFS, 
                    Best-First-Search (named A* in the code) and
                    Breadth-First-Search (named BFS in the code) functions.
                </para>
            </section>

           
            <section id="intrface.c">
                <title>intrface.c</title>
                <para>
                    This module contains the logic that manages a solver instance,
                    configures it and runs it. It used the scans module to 
                    perform the scan and other modules to configure it. Note that
                    the interface presented here is very raw, and not meant
                    to be used as an API.
                </para>
            </section>


            <section id="lib.c">
                <title>lib.c</title>
                <para>
                    This module contains the user API. It manages a sequence of 
                    instances that can be used to solve a board, and then recycled 
                    to solve another. It uses intrface.c to perform its 
                    operations, and do the actual configuring and solving. It 
                    supplies the API header file <filename>fcs_user.h</filename> 
                    which contains one function for doing any given operation, and 
                    these functions are implemented in lib.c.
                </para>
            </section>

            <section id="cmd_line.c">
                <title>cmd_line.c</title>
                <para>
                    This module can be used to analyze an array of strings 
                    (similar to that given to the <function>main()</function> 
                    function) and configure a user instance accordingly. It also 
                    implements reading such arguments from files and a presets 
                    mechanism that can be used to assign names to common 
                    configuration and load them.
                </para>
            </section>

        </section>
    </chapter>
    <chapter id="techniques">
        <title>Interesting Techniques Used throughout the Code</title>
        <section id="technique_state_representation">
            <title>State Representation</title>
            <para>
                As can be seen in <filename>state.h</filename>, &fcs; 
                supports three ways to represent a state:
            </para>
            <para>
                <orderedlist>
                    <listitem>
                        <para>
                            <emphasis>Debug States</emphasis> - 
                            in this configuration, stack counters, 
                            and cards are represented as 32-bit quantities. 
                            This configuration consumes a lot of memory, and is 
                            the slowest of the three. It is however useful for 
                            debugging, as the debugger will display the state 
                            data-structure very nicely.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Compact States</emphasis> - in this 
                            configuration the data is one buffer of chars,
                            where each card and each stack counter are 
                            represented as one character, and each freecell and 
                            foundation is one char too.
                        </para>
                        <para>
                            Determining the locations of every card is done 
                            using offset calculation.
                        </para>
                        <para>
                            This configuration consumes much less memory than 
                            Debug States, but it doesn't scale well to games 
                            where the stacks can contain a lot of cards.
                            The reason is that every stack be of a fixed size
                            (so offset would be determined by means of 
                            multiplication).
                        </para>
                        <para>
                            This configuration used to be the fastest for 
                            limited stack games such as Freecell. After 
                            &fcs; 2.6.x, it seems that Indirect Stack States 
                            has become slightly faster than it, too.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Indirect Stack States</emphasis> - 
                            in this configuration 
                            each stack is a pointer to a stack in memory. 
                            The stacks are also collected and there is one copy
                            of each stack organization (say [KS QH 6H]) in 
                            memory. Since a pointer to a stack uniquely 
                            identifies a stack, the states can be compared by
                            comparing their memory contents.
                        </para>
                        <para>
                            This is now the default configuration, and in the 
                            2.5.x development tree, many enhancements were done to 
                            optimize it. It was benchmarked to be slightly faster 
                            than Compact States, even for games like freecell.
                        </para>
                    </listitem>
                </orderedlist>
            </para>
        </section>

        <section id="technique_indirect_stack_states_algorithms">
            <title>Indirect Stack States Algorithms</title>
            <para>
                The stacks are kept in their own stack collection in the 
                freecell_solver_instance struct. When a test wishes to 
                create a derived states, it first copies the state, and then 
                marks the flags of all the stacks as cleared. (check 
                <symbol>(*Mark STACKS_COW_CLEAR *)</symbol> in the code).
            </para>
            <para>
                Later on when a stack is changed, its flag is set, and a 
                stack is copied to a hard-thread wide indirect stacks buffer 
                and modified there. (check (*Mark STACKS_COW_COPY_STACK*) ).
            </para>
            <para>
                The check_and_add_state function then, when checking a 
                new state, ignores those stacks whose flag was not set, 
                and collects the stacks whose flag was set.
                ( <symbol>(*Mark STACKS_COW_CACHING*)</symbol> ). The 
                memory for the collected stacks is allocated compactly in 
                a segment, where one stack starts after the other
                (check <filename>alloc.c</filename> and <filename>alloc.h</filename>). 
                If the stack was found in the collection the memory that was 
                allocated is freed for use by future stacks).
            </para>
        </section>

        <section id="technique_extended_states">
            <title>Extended States</title>
            <para>
                For each position in the game graph, Freecell Solver maintains a 
                data structure that identifies it called 
                <type>fcs_state_t</type>. This contains the cards in the 
                stacks and the freecells, and the value of the foundations. The 
                stacks and freecells are uniquely sorted to avoid states that 
                are identical except for a different permutation of the stacks 
                or the freecells.
            </para>
            <para>
                <type>fcs_state_t</type> is the first member of
                <type>fcs_state_with_locations_t</type>, that defines some
                other data. The real locations of the stacks and freecells are
                stored there for instance, as well as some graph information. See
                Canonization and Normalization in the terminology.
            </para>
        </section>
        <section id="technique_the_states_graph_and_its_use">
            <title>The States Graph and its Use</title>
            <para>
                When a brand new state is discovered its parent is assigned to be
                the state from which it is derived. (check <symbol>(*Mark
                    STATE_PARENT*)</symbol>). Its depth is assigned to be the depth
                of the parent + 1. There is a command line option
                (--reparent-states) that specifies that if an existing state whose
                depth is higher than the depth of state it was derived from + 1 is
                reached, then its parent would be re-assigned.
            </para>
            <para>
                An extended state has a num_active_children counter that 
                specifies how many of those states that consider it their parent 
                were still not marked as dead ends. If this counter reaches 0, 
                this state also becomes inactive.
            </para>

            <para>
                The state has a vector of flags called scan_visited, that specifies
                if a given scan has visited it yet. If it is a complete scan it can
                also mark it as dead end should it:
            </para>

            <para>
                <orderedlist>
                    <listitem>
                        <para>
                            Recurse out of it if it's a DFS scan.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Find that it has no derived states if it is a 
                            Best-First Search scan.
                        </para>
                    </listitem>
                </orderedlist>
            </para>
            <para>
                If it is marked as dead end, then its parent's counter would be 
                incremented. If the latter is zero, the process may continue to 
                the grand parent and so forth.
            </para>
        </section>

        <section id="technique_life_cycle_of_a_f_s_instance_t">
            <title>The Life-Cycle of a freecell_solver_instance_t</title>
            <para>
                A <type>freecell_solver_instance_t</type> is allocated by 
                <filename>lib.c</filename> to start solving a board. The logic
                of solving a board is present in <filename>intrface.c</filename> 
                while the stubs to use it are implemented in 
                <filename>lib.c</filename>.
            </para>
            <para>
                After an instance is allocated, it should be parametrized to
                specify how it will solve the board. Afterwards, 
                <function>freecell_solver_init_instance()</function> should
                be called. After that, 
                <function>freecell_solver_solve_instance()</function> should
                be called for the first time, and 
                <function>freecell_solver_resume_instance()</function> afterwards.
                (these functions solve until they reach a limit of iterations 
                number.)
            </para>
            <para>
                If one would like to use the instance to solve another board, it is
                possible to recycle it by calling
                <function>freecell_solver_recycle_instance()</function>.  This will
                keep its configuration but free all its associated resources, and
                thus will not require parsing the command line again.
            </para>
            <para>
                The function that calls the actual scans is 
                <function>run_hard_thread()</function>, which is called from 
                within <function>freecell_solver_resume_instance()</function>.
            </para>
        </section>

        <section id="technique_compact_allocation">
            <title>Compact Allocation</title>
            <para>
                Most resources that are allocated arbitrarily in &fcs; are
                allocated in a compact manner. I.e: instead of being individually
                malloced, they are allocated in segments and placed one after the
                other. The segments are dynamically allocated and kept at a fixed
                location in memory. If more memory is needed, another segment is
                allocated.
            </para>
            <para>
                There are two modules whose code is used to achieve this end:
            </para>
            <para>
                <orderedlist>
                    <listitem>
                        <para>
                            <filename>fcs_isa.c</filename>/<filename>fcs_isa.h</filename> - 
                            Short for Indirect State Allocation, this module 
                            allocated vectors of states, each one is of constant 
                            size.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <filename>alloc.c</filename>/<filename>alloc.h</filename> -
                            allocates blocks of arbitrary size in a compact manner.
                        </para>
                    </listitem>
                </orderedlist>
            </para>

            <para>
                Both of these modules support releasing the last allocated block
                and the last one alone.
            </para>        
            <para>
                Compact allocation is used for the following resources.
            </para>
            <para>
                <orderedlist>
                    <listitem>
                        <para>
                            <emphasis>States</emphasis> - using fcs_isa. A derived 
                            state is allocated using the hard thread's allocator, 
                            and it is modified with the appropriate moves. If it 
                            is found to have already existed, it is released. 
                            Else, it is kept and a pointer to it can be found 
                            in the states collection.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Card stacks</emphasis> - if a card stack was 
                            modified, it is compactly allocated (see 
                            <symbol>(*Mark COMPACT_ALLOC_CARD_STACKS*)</symbol> ), 
                            before one checks to see if it is present in the 
                            stacks collection. If it was found there, its memory 
                            is released. Else, it is kept there.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Move stacks</emphasis> - 
                            the move stacks leading to the parent are compactly 
                            allocated (see (*Mark COMPACT_ALLOC_MOVE_STACKS*)).
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Hash Elements</emphasis> - The elements of 
                            the hash linked lists are compactly allocated with a 
                            specialized hash allocator.
                        </para>
                    </listitem>
                </orderedlist>
            </para>
        </section>
    </chapter>
    <chapter id="scm">
        <title>Software Configuration Management</title>
        <section id="scm_game_presets_configuration">
            <title>Game Presets Configuration</title>
            <para>
                The info for generating the game presets lie in the file <filename>gen_presets.pl</filename>. It
                uses <ulink url="http://groups.yahoo.com/group/fc-solve-discuss/message/51">data 
                    structure inheritance</ulink> to determine the exact 
                parameters to be included in each preset. Its output should 
                later be incorporated into <filename>presets.c</filename>.
            </para>
        </section>
        <section id="scm_maintaining_a_list_of_modules">
            <title>Maintaining a list of Modules</title>
            <para>
                The script <filename>gen_makefile.pl</filename> maintains a list 
                of modules and headers across all makefiles that are 
                distributed as part of Freecell Solver.
            </para>
            <para>
                Notice that the Win32 makefile is generated from a hard-coded
                template, while the other makefiles are read and modified by it.
            </para>
        </section>

        <section id="scm_generating_the_site">
            <title>Generating the Site</title>
            <para>
                The site lies in the <ulink url="http://cvs.berlios.de/cgi-bin/viewcvs.cgi/fc-solve/fc-solve/site/wml/">sub-directory of 
                    fc-solve/site/wml in the CVS</ulink> and 
                is generated using GNU Make, WebMetaLanguage and CVS glue. If a 
                development version is present, it is checked out of the CVS, 
                packed into an archive, and placed on the site with a link in 
                the downloads page.
            </para>

            <para>
                The <ulink url="http://fc-solve.berlios.de/">main site
                    at BerliOS</ulink> 
                is generated from a makefile and both uploaded to 
                its place using rsync.
            </para>

            <para>
                The site generation process also generates a zip archive of the 
                latest stable version so it can be used to automatically 
                compile the Win32 binary.            
            </para>
        </section>

        <section id="scm_freecell_solver_config">
            <title>freecell-solver-config</title>
            <para>
                The autoconf process creates a freecell-solver-config program that
                can be used as an aid in programs wishing to compile and link
                against &fcs;. It is generated from freecell-solver-config.in by
                the configure script and is installed system-wide.            
            </para>
        </section>


        <section id="scm_win32_binary">
            <title>The Win32 Binary</title>
            <para>
                The Win32 binary is compiled by a batch file placed on the site 
                and found in the CVS in the location 
                <ulink url="http://cvs.berlios.de/cgi-bin/viewcvs.cgi/fc-solve/fc-solve/site/wml/src/win32_build/bootstrap/build.bat">/fc-solve/site/wml/src/win32_build/bootstrap/built.bat</ulink>
            </para>
            <para>
                This script should be placed on a Windows NT 4.0 and above 
                computer that has the Microsoft Visual Studio environment 
                installed. It should be placed in a directory containing only it 
                and the curl.exe executable from 
                <ulink url="http://fc-solve.berlios.de/win32_build/">the same location</ulink>.
            </para>

            <para>
                What it does is the following:
            </para>

            <para>
                <orderedlist>                
                    <listitem>
                        <para>
                            Download zip.exe and unzip.exe from the static sub-dir.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            Download fcs.zip from the dynamic sub-dir.
                        </para>
                    </listitem>
                    
                    <listitem>
                        <para>
                            Unpack fcs.zip.
                        </para>
                    </listitem>
                   
                    <listitem>
                        <para>
                            Determine its version number and record it in a 
                            variable.
                        </para>
                    </listitem>

                    <listitem>
                        <para>

                            Compile Freecell Solver.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Place the relevant files in a directory structure by 
                            copying them.
                        </para>
                    </listitem>               
                    <listitem>
                        <para>
                            Create a zip archive of them.
                        </para>
                    </listitem>          
                </orderedlist>
            </para>        
        </section>
    </chapter>
    <chapter id="terms">
        <title>Terminology</title>
        <section id="terms_terms">
            <title>Terms used throughout the Code</title>
            <variablelist>
                <title>Terms used throughout the Code</title>
                <varlistentry>
                    <term>Canonization</term>
                    <listitem>
                        <para>
                            An extended state is canonized by its stacks being
                            uniquely sorted according to their contents, and an
                            array of indexes describing their original locations
                            sorted accordingly. This is done to make sure no two
                            states with the same permutation of states exist.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Depth</term>
                    <listitem>
                        <orderedlist>
                            <listitem>
                                <para>
                                    The number of successive state &rarr;
                                    state.parent operations it take to reach the
                                    initial state which is the base of the states graph.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    In Depth-First-Search (DFS): the position of
                                    the state in the recursion stack.
                                </para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>False Impossible</term>
                    <listitem>
                        <para>
                            A false impossible is an initial board position for 
                            which the solver reports as impossible to solve, yet
                            can be solved in some way. A false impossible may be
                            considered a bug depending on the context. 
                        </para>
                        <para>
                            A meta-move scan can potentially have false 
                            impossibles, while an atomic moves one (which does not
                            prune in any way) cannot.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>False Negative</term>
                    <listitem>
                        <para>
                            See False Impossible.
                        </para>
                    </listitem>
                </varlistentry>
                
                
                <varlistentry>
                    <term>f_s_</term>
                    <listitem>
                        <para>
                            Short for freecell_solver_
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>freecell_solver_user</term>
                    <listitem>
                        <para>
                            a generic name of the API used by the programmer
                            who wishes to utilize the &fcs; library in his
                            application. Named after the prefix of the functions
                            of this library.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Graph</term>
                    <listitem>
                        <para>
                            The states in the state collection form a directed
                            graph. Each link is a state &rarr; derived state 
                            relationship.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Hard DFS</term>
                    <listitem>
                        <para>
                            A Depth-First Search scan that uses procedural 
                            recursion. Since suspending a scan and resuming it are
                            O(d) operations (where d is the depth) instead
                            of O(1) for Soft-DFS its use is deprecated. It was
                            the original scan supported by &fcs; 0.2.0 and
                            still exists in the code.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Hard Thread</term>
                    <listitem>
                        <para>
                            a collection of soft threads, that should generally be 
                            placed in one system thread. Hard thread contains 
                            resources that soft threads from different hard 
                            threads would interfere with each other in allocating. 
                            Hard threads contain a collection of state packs, and 
                            various counters and other variables.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Instance</term>
                    <listitem>
                        <para>
                            an initial board, a collection of states and all the
                            scans associated with it. An instance is initialized
                            whenever one wishes to solve new board. By using
                            command line parameters it is possible to configure it
                            to solve the board in many ways. Instance logic is
                            implemented in <filename>intrface.c</filename>, and 
                            the user API is implemented in 
                            <filename>lib.c</filename>. Users are advised to make 
                            use of the command line interface in 
                            <filename>cmd_line.c</filename>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Intractable</term>
                    <listitem>
                        <para>
                            An initial layout of the board that cause the solver
                            to terminate the scan prematurely (due to limitations
                            on the iterations and the such) without determining
                            whether the board was solvable or not.
                        </para>
                    </listitem>
                </varlistentry>            
                <varlistentry>
                    <term>Iterations</term>
                    <listitem>
                        <para>
                            the number of states checked by a scan, or by all the
                            scans of a hard thread or of an instance. An iterations                         limit (called num_times in the code) is used to 
                            restrict a soft thread, hard thread or instance from
                            running too long, and to allocate time quotas for 
                            different soft threads.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Meta-Move</term>
                    <listitem>
                        <para>
                            A move that consists of several individual moves
                            done as one, to move from state to a derived state.
                            Some of the Freecell tests and all of the
                            Simple Simon tests generate meta-moves.
                        </para>
                    </listitem>
                </varlistentry>            
                <varlistentry>
                    <term>Move</term>
                    <listitem>
                        <para>
                            A one-time displacements of cards from stacks to
                            stacks, from stacks to freecells, or from freecells to
                            stacks. Also contain some special moves such as those
                            for canonizing stacks, and separators. Also see Move
                            Stacks.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Move Stacks</term>
                    <listitem>
                        <para>
                            A sequence of moves implemented in its own class
                            (check <filename>move.c</filename> and 
                            <filename>move.h</filename>).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Normalization</term>
                    <listitem>
                        <para>
                            normalization is the opposite of canonization. It is
                            meant to bring the stacks and freecells to their 
                            absolute locations. It is normally done only when
                            presenting a state to the user or to a code that
                            uses the API.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Packs</term>
                    <listitem>
                        <para>
                            see State Packs
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Parent</term>
                    <listitem>
                        <para>
                            The state from which one state in the state graph was
                            initially derived from. It is possible that this state
                            would eventually be reached from a different state, but
                            its parent in that case, remains the same.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Presets</term>
                    <listitem>
                        <para>
                            <orderedlist>
                                <listitem>
                                    <para>
                                        A structure specifying the type of game 
                                        according to number of stacks, number of 
                                        freecells, number of decks, whether kings 
                                        can be placed in empty stacks, if 
                                        sequences have unlimited moves, and how 
                                        stacks are built by. Defined in 
                                        <filename>preset.c</filename>.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        A set of command line arguments to be 
                                        processed as if they were given on the 
                                        command line. Can be used to shorten 
                                        command lines. For instance 
                                        "-l cool-jives" or "-l john-galt-line" 
                                        load the presets "cool-jives" and 
                                        "john-galt-line" respectively. Implemented 
                                        mostly in <filename>cmd_line.c</filename>.
                                    </para>
                                </listitem>
                            </orderedlist>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Reparent</term>
                    <listitem>
                        <para>
                            Let's suppose state DEST has been derived from state
                            SRC. If the SRC.depth+1 is less than DEST.depth than
                            DEST's parent will be reassigned to SRC. (if
                            reparenting is enabled)
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Secondary Hash Value</term>
                    <listitem>
                        <para>
                            a hash value that is calculated for every state that 
                            is not used to determine the location of the element 
                            in the hash table, but that is used for comparison. 
                            That is done in order to avoid needlessly comparing 
                            two different states with the same hash value.
                        </para>
                        <para>
                            Freecell Solver uses a 32-bit primary hash value. As
                            such it is susceptible to the birthday paradox starting
                            at about 2<superscript>16</superscript>. A secondary
                            hash value with extra 32-bits ensures a collision of both
                            hash values will only happen at around 2<superscript>32</superscript> states, 
                            which is much more states than most 32-bit systems can 
                            handle.                        
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Soft DFS</term>
                    <listitem>
                        <para>
                            A depth-first search scan that does not utilize
                            procedural recursion. In &fcs;, this utilizes a stack
                            of records, each containing the current state, the
                            current test, the list of derived states, and other
                            information. This deviates from the standard scheme
                            that puts every state at the end of one stack scheme
                            (that exists in <ulink
                                url="http://www.shlomifish.org/lm-solve/">LM-Solve</ulink>
                            for example) and is harder to maintain, but can be
                            fine-tuned and conserve resources more easily.

                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Soft Thread</term>
                    <listitem>
                        <para>
                            a singular continuous scan operating on a states 
                            collection. It can be Soft-DFS, Hard-DFS or Best 
                            First Search. There could be any number of soft 
                            threads in a hard thread.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Stacks</term>
                    <listitem>
                        <para>
                            <orderedlist>
                                <listitem>
                                    <para>
                                        Move Stacks (refer to them)
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        Columns of the freecell games.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        The stacks used for maintaining the 
                                        Soft-DFS recursion.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        The environment recursion stack.
                                    </para>
                                </listitem>
                            </orderedlist>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>State</term>
                    <listitem>
                        <para>
                            the position of the game at any given situation. A
                            state accurately describes the contents of the stacks,
                            freecells, and foundations at any given time. A human
                            seeing a state can solve the game from it without
                            further information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>State Collection</term>
                    <listitem>
                        <para>
                            a collection that collects every state once and only
                            once.  It can be sought of as an associate array (or a
                            map) of keys only. In fact, the keys are mapped to
                            extra information such as depth, order of stacks and
                            freecells and others, so it is more of a key-value
                            collection.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>State Packs</term>
                    <listitem>
                        <para>
                            An allocation of states. Each state pack is a buffer in
                            memory, that contain an array of states. Each buffer
                            remains at a constant memory location, but more buffers
                            are allocated as necessary. The implementation of State
                            packs reside in the files
                            <filename>fcs_isa.c</filename> and
                            <filename>fcs_isa.h</filename>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Test Groups</term>
                    <listitem>
                        <para>
                            a grouping of tests that dictate which one should be 
                            performed one after the and placed into the same 
                            derived states list. Afterwards, this list can be 
                            randomized, or prioritized.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Tests</term>
                    <listitem>
                        <para>
                            A function that accepts a source state as input and 
                            fills a list of derived states according to the moves 
                            it can perform. Each game type has several type of 
                            tests, which can be ordered and grouped according to 
                            input from the user
                        </para>
                    </listitem>
                </varlistentry>
                
                <!--
                I keep the following code around to be used as a template for
                new entries:

                <varlistentry>
                    <term></term>
                    <listitem>
                        <para>
                        </para>
                    </listitem>
                </varlistentry>
                -->

            </variablelist>
        </section>
    </chapter>
</book>
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
